
#include <pspsdk.h>
#include <pspkernel.h>
#include <pspthreadman_kernel.h>
#include <pspopenpsid.h>
#include <psputilsforkernel.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

//#include <systemctrl.h>
#include "systemctrl_me.h"

#include "horoscope_patch_list.h"

PSP_MODULE_INFO("decrypt_engine", 0x1006, 1, 0);
PSP_MAIN_THREAD_ATTR(0);
//STMOD_HANDLER previous = NULL;


#define JAL_OPCODE	0x0C000000
#define J_OPCODE	0x08000000
#define SC_OPCODE	0x0000000C
#define JR_RA		0x03e00008

#define NOP	0x00000000

#define MAKE_JUMP(a, f) _sw(J_OPCODE | (((u32)(f) & 0x0ffffffc) >> 2), a); 
#define MAKE_CALL(a, f) _sw(JAL_OPCODE | (((u32)(f) >> 2)  & 0x03ffffff), a); 
#define MAKE_SYSCALL(a, n) _sw(SC_OPCODE | (n << 6), a);
#define JUMP_TARGET(x) (0x80000000 | ((x & 0x03FFFFFF) << 2))

u32 module_sdk_version = 0x03060010;

void *SystemCtrlForKernel_1F3037FB( int(* func)() );
char *sctrlSEGetUmdFile();
//void *sctrlKernelMalloc(int);
//int sctrlKernelFree(void *);

typedef struct
{
	u32		signature;  // 0
	u16		attribute; // 4  modinfo
	u16		comp_attribute; // 6
	u8		module_ver_lo;	// 8
	u8		module_ver_hi;	// 9
	char	modname[28]; // 0A
	u8		version; // 26
	u8		nsegments; // 27
	int		elf_size; // 28
	int		psp_size; // 2C
	u32		entry;	// 30
	u32		modinfo_offset; // 34
	int		bss_size; // 38
	u16		seg_align[4]; // 3C
	u32		seg_address[4]; // 44
	int		seg_size[4]; // 54
	u32		reserved[5]; // 64
	u32		devkitversion; // 78
	u32		decrypt_mode; // 7C 
	u8		key_data0[0x30]; // 80
	int		comp_size; // B0
	int		_80;	// B4
	int		reserved2[2];	// B8
	u8		key_data1[0x10]; // C0
	u32		tag; // D0
	u8		scheck[0x58]; // D4
	u32		key_data2; // 12C
	u32		oe_tag; // 130
	u8		key_data3[0x1C]; // 134
} __attribute__((packed)) PSP_Header;


void ClearCaches()
{
	sceKernelIcacheInvalidateAll();
	sceKernelDcacheWritebackInvalidateAll();	
}


typedef struct{
	u32 tag;
	u8 key[0x10];
	u32 code;//scramble ?
	u32 type;
} user_decryptor;

user_decryptor decryptkey_table[] = {
	{ 0xd91609f0, { 0xD0, 0x36, 0x12, 0x75, 0x80, 0x56, 0x20, 0x43, 0xC4, 0x30, 0x94, 0x3E, 0x1C, 0x75, 0xD1, 0xBF }, 0x5d, 2},
//	{ 0xd9160af0, { 0x10, 0xA9, 0xAC, 0x16, 0xAE, 0x19, 0xC0, 0x7E, 0x3B, 0x60, 0x77, 0x86, 0x01, 0x6F, 0xF2, 0x63 }, 0x5d, 2},//
//	{ 0xd9160bf0, { 0x83, 0x83, 0xF1, 0x37, 0x53, 0xD0, 0xBE, 0xFC, 0x8D, 0xA7, 0x32, 0x52, 0x46, 0x0A, 0xC2, 0xC2 }, 0x5d, 2},//
//	{ 0xd91611f0, { 0x61, 0xB0, 0xC0, 0x58, 0x71, 0x57, 0xD9, 0xFA, 0x74, 0x67, 0x0E, 0x5C, 0x7E, 0x6E, 0x95, 0xB9 }, 0x5d, 2},//
	{ 0xd91612f0, { 0x9e, 0x20, 0xe1, 0xcd, 0xd7, 0x88, 0xde, 0xc0, 0x31, 0x9b, 0x10, 0xaf, 0xc5, 0xb8, 0x73, 0x23 }, 0x5d, 2},
	{ 0xd91613f0, { 0xEB, 0xFF, 0x40, 0xD8, 0xb4, 0x1a, 0xe1, 0x66, 0x91, 0x3b, 0x8f, 0x64, 0xb6, 0xfc, 0xb7, 0x12 }, 0x5d, 2},
	{ 0xd91614f0, { 0xFD, 0xF7, 0xB7, 0x3C, 0x9F, 0xD1, 0x33, 0x95, 0x11, 0xB8, 0xB5, 0xBB, 0x54, 0x23, 0x73, 0x85 }, 0x5d, 2},
	{ 0xd91615f0, { 0xC8, 0x03, 0xE3, 0x44, 0x50, 0xF1, 0xE7, 0x2A, 0x6A, 0x0D, 0xC3, 0x61, 0xB6, 0x8E, 0x5F, 0x51 }, 0x5d, 2},
	{ 0xd91616f0, { 0x53, 0x03, 0xB8, 0x6A, 0x10, 0x19, 0x98, 0x49, 0x1C, 0xAF, 0x30, 0xE4, 0x25, 0x1B, 0x6B, 0x28 }, 0x5d, 2},
	{ 0xd91617f0, { 0x02, 0xFA, 0x48, 0x73, 0x75, 0xAF, 0xAE, 0x0A, 0x67, 0x89, 0x2B, 0x95, 0x4B, 0x09, 0x87, 0xA3 }, 0x5d, 2},
	{ 0xd91618f0, { 0x96, 0x96, 0x7C, 0xC3, 0xF7, 0x12, 0xDA, 0x62, 0x1B, 0xF6, 0x9A, 0x9A, 0x44, 0x44, 0xBC, 0x48 }, 0x5d, 2},
	{ 0xd91619f0, { 0xE0, 0x32, 0xA7, 0x08, 0x6B, 0x2B, 0x29, 0x2C, 0xD1, 0x4D, 0x5B, 0xEE, 0xA8, 0xC8, 0xB4, 0xE9 }, 0x5d, 2},
	{ 0xd9161af0, { 0x27, 0xE5, 0xA7, 0x49, 0x52, 0xE1, 0x94, 0x67, 0x35, 0x66, 0x91, 0x0C, 0xE8, 0x9A, 0x25, 0x24 }, 0x5d, 2},
	{ 0xd91620f0, { 0x52, 0x1C, 0xB4, 0x5F, 0x40, 0x3B, 0x9A, 0xDD, 0xAC, 0xFC, 0xEA, 0x92, 0xFD, 0xDD, 0xF5, 0x90 }, 0x5d, 2},
	{ 0xd91621f0, { 0xD1, 0x91, 0x2E, 0xA6, 0x21, 0x14, 0x29, 0x62, 0xF6, 0xED, 0xAE, 0xCB, 0xDD, 0xA3, 0xBA, 0xFE }, 0x5d, 2},
	{ 0xd91622f0, { 0x59, 0x5D, 0x78, 0x4D, 0x21, 0xB2, 0x01, 0x17, 0x6C, 0x9A, 0xB5, 0x1B, 0xDA, 0xB7, 0xF9, 0xE6 }, 0x5d, 2},
	{ 0xd91623f0, { 0xAA, 0x45, 0xEB, 0x4F, 0x62, 0xFB, 0xD1, 0x0D, 0x71, 0xD5, 0x62, 0xD2, 0xF5, 0xBF, 0xA5, 0x2F }, 0x5d, 2},
	{ 0xd91624f0, { 0x61, 0xB7, 0x26, 0xAF, 0x8B, 0xF1, 0x41, 0x58, 0x83, 0x6A, 0xC4, 0x92, 0x12, 0xCB, 0xB1, 0xE9 }, 0x5d, 2},
	{ 0xd91628f0, { 0x49, 0xA4, 0xFC, 0x66, 0xDC, 0xE7, 0x62, 0x21, 0xDB, 0x18, 0xA7, 0x50, 0xD6, 0xA8, 0xC1, 0xB6 }, 0x5d, 2},
//	{ 0xd91680f0, { 0x2C, 0x22, 0x9B, 0x12, 0x36, 0x74, 0x11, 0x67, 0x49, 0xD1, 0xD1, 0x88, 0x92, 0xF6, 0xA1, 0xD8 }, 0x5d, 6},//
	{ 0xd91681f0, { 0x52, 0xB6, 0x36, 0x6C, 0x8C, 0x46, 0x7F, 0x7A, 0xCC, 0x11, 0x62, 0x99, 0xC1, 0x99, 0xBE, 0x98 }, 0x5d, 6},
	{ 0x0b2b80f0, { 0x57, 0xb4, 0xa6, 0x5c, 0x75, 0x2d, 0xb9, 0x4d, 0xe1, 0x67, 0xe3, 0x31, 0xbf, 0x4d, 0x70, 0xf8 }, 0x5c, 6},
//	{ 0x457b80f0, { 0xd4, 0x35, 0x18, 0x02, 0x29, 0x68, 0xfb, 0xa0, 0x6a, 0xa9, 0xa5, 0xed, 0x78, 0xfd, 0x2e, 0x9d }, 0x5b, 6},//
//	{ 0x457B0CF0, { 0xAC, 0x34, 0xBA, 0xB1, 0x97, 0x8D, 0xAE, 0x6F, 0xBA, 0xE8, 0xB1, 0xD6, 0xDF, 0xDF, 0xF1, 0xA2 }, 0x5B, 2 },//
//	{ 0x457B8AF0, { 0x47, 0xEC, 0x60, 0x15, 0x12, 0x2C, 0xE3, 0xE0, 0x4A, 0x22, 0x6F, 0x31, 0x9F, 0xFA, 0x97, 0x3E }, 0x5B, 6 }//
};

void fill_vram(u32 color)
{
	u32 *p = (u32*)0x44000000;

	while (p < (u32*)0x44200000)
		*p++ = color;
}

int (* decrypt_next)() = NULL;
int (* MesgLedDecrypt)(u32* a0/*tag*/,u32* a1/*key*/,int a2,u8 *buff,int t0/*size*/,int *t1/*ret*/,int t2/*flag*/,char *t3 ,
						   int sp0 , int sp1/* type*/ , u8 *sp2 , u8 *sp3) = NULL;

int opnssmp_decrypt_helper(u32* a0/*tag*/,u32* a1/*key*/,int a2,u8 *buff,int t0/*size*/,int *t1/*ret*/,int t2/*flag*/,char *t3 ,
						   int sp0 , int sp1/* type*/ , u8 *sp2 , u8 *sp3)
{
	PSP_Header *head=(PSP_Header *)buff;
	u32 tag = head->tag;
	int i;

	for(i=0;i< sizeof(decryptkey_table) / sizeof(user_decryptor) ;i++)
	{
		if( decryptkey_table[i].tag == tag )
		{
			int ret;
			if( (ret = MesgLedDecrypt( &(decryptkey_table[i].tag) , decryptkey_table[i].key , decryptkey_table[i].code , buff , t0 , t1 , 0 ,NULL 
				,0 , decryptkey_table[i].type , NULL , NULL )) >= 0 )
			{
				fill_vram( 0x00FF00FF);

//				printf("Fooooooooooooooooooooooo\n");
				return ret;
			}			
//				printf("Eooooooooooooooooooooooo\n");

			break;
		}
	}

	if( !decrypt_next )
		return -1;

//	return MesgLedDecrypt( a0 , a1 , a2 , buff , t0 , t1 , t2 , t3 , sp0 , sp1 , sp2 , sp3 );
	return decrypt_next( a0 , a1 , a2 , buff , t0 , t1 , t2 , t3 , sp0 , sp1 , sp2 , sp3 );
}
	
u32 sceMesgLedDecryptGame[][2] = {
	{ 0x00002BB8, 0x00002E50 }, // 01g
	{ 0x00002F98, 0x00003230 }, // 02g
	{ 0x00003338, 0x000035D0 }// 03g
};

int module_start()
{	
	int model = sceKernelGetModel();
	if( model > 2)
		model = 2;

	SceModule2 *mod = sceKernelFindModuleByName("sceMesgLed");	
	{
		u32 text_addr = mod->text_addr;	
		decrypt_next = (void *)SystemCtrlForKernel_1F3037FB( opnssmp_decrypt_helper );

//		MAKE_CALL( text_addr + 0x00003194 , opnssmp_decrypt_helper );
//		MAKE_CALL( text_addr + sceMesgLedDecryptGame[ model ][0], opnssmp_decrypt_helper );
//		MAKE_CALL( text_addr + sceMesgLedDecryptGame[ model ][1], opnssmp_decrypt_helper );
		MesgLedDecrypt =(void *)(text_addr+ 0xE0);
	}		

		
	ClearCaches();

//	previous = sctrlHENSetStartModuleHandler(sceKernelApplyPspRelSectionPatched);
	return 0;
}
